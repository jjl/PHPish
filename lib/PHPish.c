/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2205 from the
 * contents of PHPish.xs. Do not edit this file, edit PHPish.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "lib/PHPish.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#define sv_is_glob(sv) (SvTYPE(sv) == SVt_PVGV)

#define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#define PERL_DECIMAL_VERSION \
	PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#define PERL_VERSION_GE(r,v,s) \
	(PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))

#if PERL_VERSION_GE(5,11,0)
# define sv_is_regexp(sv) (SvTYPE(sv) == SVt_REGEXP)
#else /* <5.11.0 */
# define sv_is_regexp(sv) 0
#endif /* <5.11.0 */

#define sv_is_string(sv) \
	(!sv_is_glob(sv) && !sv_is_regexp(sv) && \
	 (SvFLAGS(sv) & (SVf_IOK|SVf_NOK|SVf_POK|SVp_IOK|SVp_NOK|SVp_POK)))

static HV *array_stash;

static void verify_string(SV* thing) {
    if (!sv_is_string(thing)) {
        croak("Not a string");
    }
}

static bool is_parray(SV *self) {
    SV *aself;
    if (!SvROK(self)) {
        return 0;
    }
    aself = SvRV(self);
    if (!(SvTYPE(aself) == SVt_PVAV)) {
        return 0;
    }
    if (!SvOBJECT(aself)) {
        return 0;
    }
    if (!(SvSTASH(aself) == array_stash)) {
        return 0;
    }
    return 1;
}

static void verify_parray (SV *thing) {
    if (!is_parray(thing)) {
        croak("Not a PHPish::Array");
    }
}





#line 69 "lib/PHPish.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 121 "lib/PHPish.c"

XS(XS_PHPish__Array_new_empty); /* prototype to pass -Wmissing-prototypes */
XS(XS_PHPish__Array_new_empty)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "classname");
    {
#line 69 "lib/PHPish.xs"
    AV *aself;
#line 136 "lib/PHPish.c"
	SV *	RETVAL;
	SV *	classname = ST(0);
#line 71 "lib/PHPish.xs"
    aself = newAV();
    RETVAL = newRV_noinc((SV *) aself);
    av_store(aself,0,newRV_noinc((SV *) newAV()));
    av_store(aself,1,newRV_noinc((SV *) newHV()));
    sv_bless(RETVAL,array_stash);
#line 145 "lib/PHPish.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_PHPish__Array_push_kv); /* prototype to pass -Wmissing-prototypes */
XS(XS_PHPish__Array_push_kv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "self, key, value");
    {
#line 82 "lib/PHPish.xs"
    AV *aself;
    AV *apair;
    SV *pair;
    AV *aseq;
    HV *hlookup;
    I32 index;
#line 171 "lib/PHPish.c"
	SV *	self = ST(0);
	SV *	key = ST(1);
	SV *	value = ST(2);
#line 89 "lib/PHPish.xs"
    verify_parray(self);
    verify_string(key);
    aself = (AV *) SvRV(self);
    apair = newAV();
    av_store(apair,0,newSVsv(key));
    av_store(apair,1,newSVsv(value));
    pair = newRV_noinc((SV *)apair);
    aseq = (AV *) SvRV(*av_fetch(aself,0,0));
    index = av_len(aseq) + 1;
    av_store(aseq,index,pair);
    hlookup = (HV *) SvRV(*av_fetch(aself,1,0));
    hv_store_ent(hlookup, key, newSViv(index), 0);
#line 188 "lib/PHPish.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_PHPish); /* prototype to pass -Wmissing-prototypes */
XS(boot_PHPish)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("PHPish::Array::new_empty", XS_PHPish__Array_new_empty, file);
        newXS("PHPish::Array::push_kv", XS_PHPish__Array_push_kv, file);

    /* Initialisation Section */

#line 64 "lib/PHPish.xs"
    array_stash = gv_stashpv("PHPish::Array",1);

#line 222 "lib/PHPish.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

